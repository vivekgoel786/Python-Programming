cor_matrix <- cor(model_data_scaled[scale_vars], use = "complete.obs")
print(cor_matrix)

#try
install.packages("corrplot")
library(corrplot)
corrplot(cor_matrix, method = "circle", type = "upper", tl.cex = 0.8)



# Install if not installed
install.packages("car")
library(car)

# Fit a linear model using the same predictors
lm_model <- lm(UNEMP_RATE_lead2 ~ pct_change_GDP_lag1 + pct_change_AVG_MONTHLY_WAGE_lead1,
               data = model_data_scaled)

# Calculate VIFs
vif(lm_model)

lm_model_full <- lm(~ UNEMP_RATE_lead2 + pct_change_GDP_lag1 + pct_change_AVG_MONTHLY_WAGE_lead1,
                    data = model_data_scaled)

vif(lm_model_full)


# Predict class probabilities for each observation
predicted_probs <- predict(model, type = "prob")

# View the first few rows
head(predicted_probs)

# Add to original data
model_data_with_probs <- cbind(model_data_scaled, predicted_probs)

# View result
head(model_data_with_probs)

predicted_class <- predict(model, type = "class")

# Add predicted class to data
model_data_with_probs$predicted_class <- predicted_class

# View actual vs predicted
table(Actual = model_data_with_probs$Economy_State_dummy,
      Predicted = model_data_with_probs$predicted_class)







install.packages(c("caret", "MLmetrics", "yardstick", "DescTools", "irr"))
library(caret)
library(MLmetrics)
library(yardstick)
library(DescTools)
library(irr)

predicted_class <- predict(model, type = "class")
actual_class <- model_data_scaled$Economy_State_dummy

conf_mat <- table(Actual = actual_class, Predicted = predicted_class)
print(conf_mat)

confusionMatrix(predicted_class, actual_class)

accuracy <- mean(predicted_class == actual_class)
print(accuracy)


class_freq <- prop.table(table(actual_class))
correct_by_class <- tapply(predicted_class == actual_class, actual_class, mean)
weighted_accuracy <- sum(class_freq * correct_by_class)
print(weighted_accuracy)

kendall_tau_b <- Kendall(as.numeric(predicted_class), as.numeric(actual_class))$tau
print(kendall_tau_b)


somers_d <- SomersDelta(as.numeric(predicted_class), as.numeric(actual_class))
print(somers_d)


# Convert to factor with correct levels
predicted_class <- factor(predicted_class, levels = levels(actual_class))

precision_by_class <- Precision(predicted_class, actual_class, average = "none")
recall_by_class <- Recall(predicted_class, actual_class, average = "none")
f1_by_class <- F1_Score(predicted_class, actual_class, average = "none")

print("Precision by class:")
print(precision_by_class)

print("Recall by class:")
print(recall_by_class)

print("F1 Score by class:")
print(f1_by_class)



precision_macro <- mean(precision_by_class)
recall_macro <- mean(recall_by_class)
f1_macro <- mean(f1_by_class)

cat("Macro-averaged precision:", precision_macro, "\n")
cat("Macro-averaged recall:", recall_macro, "\n")
cat("Macro-averaged F1:", f1_macro, "\n")



support <- as.numeric(table(actual_class))
total <- sum(support)

precision_weighted <- sum(precision_by_class * support) / total
recall_weighted <- sum(recall_by_class * support) / total
f1_weighted <- sum(f1_by_class * support) / total

cat("Weighted-averaged precision:", precision_weighted, "\n")
cat("Weighted-averaged recall:", recall_weighted, "\n")
cat("Weighted-averaged F1:", f1_weighted, "\n")



metrics_df <- data.frame(
  Class = levels(actual_class),
  Precision = precision_by_class,
  Recall = recall_by_class,
  F1 = f1_by_class
)
print(metrics_df)

