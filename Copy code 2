import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.calibration import CalibratedClassifierCV
from sklearn.preprocessing import StandardScaler

# Observed defaults (binary labels)
defaults = np.array([
    0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 
    0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 
    0, 0, 0, 0, 0, 0, 0
])

# PD scores (higher means lower risk)
pd_scores = np.array([
    6.6, 5.9, 6.1, 7.4, 7.2, 7.9, 5.1, 4.6, 7.9, 7.5,
    6.2, 4.8, 8.2, 6.8, 5.2, 6.0, 3.6, 7.7, 6.2, 6.3,
    8.7, 6.1, 6.2, 6.9, 4.6, 8.2, 5.7
])

# Define master scale with probability ranges
master_scale = {
    "Very Low Risk": (0.00, 0.01),  # 0% - 1% default probability
    "Low Risk": (0.01, 0.03),       # 1% - 3%
    "Moderate Risk": (0.03, 0.07),  # 3% - 7%
    "High Risk": (0.07, 0.15),      # 7% - 15%
    "Very High Risk": (0.15, 0.30), # 15% - 30%
    "Default Likely": (0.30, 1.00)  # 30% - 100%
}

# Standardize PD scores
scaler = StandardScaler()
X_scaled = scaler.fit_transform(pd_scores.reshape(-1, 1))

# Train Logistic Regression model
base_model = LogisticRegression(solver='lbfgs')

# Use CalibratedClassifierCV for Platt Scaling
calibrated_model = CalibratedClassifierCV(base_model, method='sigmoid', cv='prefit')
calibrated_model.fit(X_scaled, defaults)

# Function to map probability range to PD score range
def get_pd_score_range(calibrated_model, scaler, master_scale, pd_min=0, pd_max=10):
    score_ranges = {}

    for bucket, (p_min, p_max) in master_scale.items():
        # Compute the inverse logistic function to get decision boundaries
        logit_min = np.log(p_min / (1 - p_min)) if p_min > 0 else -np.inf
        logit_max = np.log(p_max / (1 - p_max)) if p_max < 1 else np.inf

        # Convert logit values back to PD scores using inverse transformation
        min_pd_score = scaler.inverse_transform([[logit_min]])[0][0] if np.isfinite(logit_min) else pd_min
        max_pd_score = scaler.inverse_transform([[logit_max]])[0][0] if np.isfinite(logit_max) else pd_max

        # Ensure PD scores are within range [0,10]
        min_pd_score = max(pd_min, min_pd_score)
        max_pd_score = min(pd_max, max_pd_score)

        score_ranges[bucket] = (round(min_pd_score, 2), round(max_pd_score, 2))

    return score_ranges

# Get PD score ranges for each master scale bucket
score_ranges = get_pd_score_range(calibrated_model, scaler, master_scale)

# Print results
for bucket, (low, high) in score_ranges.items():
    print(f"{bucket}: PD Score Range = {low} to {high}")
